==========================================================================
这一次的文件中，加上了Makefile 文件，就不哦那个再打那长长的两条编译语句了，
直接输入：make 就行。
如果想删掉生成的可执行语句，输入：make clean
========================================================================




代码中会用到的几个函数：
atoi(char *p)
	将字符串转换成整数，会先扫描p指向的字符串，跳过空白符，遇到数字或者正负号开始，遇到非数字或者字符串结束。
	即，将字符串中的数字转换成整数型。

htonl()
	主机IP转换成无符号长整型网络字节序
htons()
	整型变量转换为主机字节序

inet_addr()
	将点分十进制IP转换为长整型IP



    
	      服务器			   	       客户端

	htonl() 主机IP  --->长整型 	   inet_addr（） 点分十进制IP--->长整型
	htons() 整型端口--->主机字节序      htons（）     整型端口--->主机字节序
 


并发型服务器：
	当有多个线程在操作时，而系统只有一个CPU，很明显，系统不可能做到同时进行一个以上的线程，它只能把CPU运行时间划分成n个时间段，每个时间段进行一个线程操作，在一个时间段进行期间，其他时间段处于挂起状态。
	由于CPU处理速度极快，所以宏观上看起来就像多个程序同时进行。

此代码的功能：
	服务器可以接收多个客户端的连接，
	客户端可以对其他所有连接到服务器的客户端群发消息
	客户端可以对连接到服务器的某个特定客户端私发消息
比如：
	客户端输入： 你好  ，则其他客户单也会收到“你好”消息
	客户端输入： xxx:你好，  则只有ID号为xxx的客户端能收到“你好”消息
		  （ID号为服务器自动分配，客户端连接上时会被告知ID号）  


编译过程：

	gcc server_concurrence.c wrap.c -o server_concurrence -lpthread

	gcc client_concurrence.c wrap.c -o client_concurrence -lpthread

执行过程：
	./server_concurrence     --->运行服务器

	./client_concurrenc 192.168.90.210 50001 
	--->运行客户端,IP是所要连接的服务器的IP，端口号写死了，为50001

========================================================================

Makefile ：
	 # $@ -->目标文件   @^ -->所有依赖文件     @< --> 第一个依赖文件

	有些命令行前加了前缀：
	“-” ---> 忽略执行此命令时遇到的错误，一般make在遇到eror时，会自动退出，我们不要让它去管代码中的error，让它从一而终，执行到底。
	“@”--->输出的信息中，不要显示出来，正常情况下，make执行过程中，会把编译过程显示出来，如果我们觉得某一行编译命令看起来很烦，就可以不要回显。



	